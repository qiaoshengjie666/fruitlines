{
  "__type__": "cc.TextAsset",
  "_name": "flatbuffers.d",
  "_objFlags": 0,
  "_native": "",
  "text": "declare module flatbuffers {\n  /**\n   * @typedef {number}\n   */\n  export type Offset = number;\n\n  /**\n   * @typedef {{\n   *   bb: flatbuffers.ByteBuffer,\n   *   bb_pos: number\n   * }}\n   */\n  export interface Table {\n    bb: ByteBuffer;\n    bb_pos: number;\n  }\n\n  /**\n   * @type {number}\n   * @const\n   */\n  export const SIZEOF_SHORT: number;\n\n  /**\n   * @type {number}\n   * @const\n   */\n  export const SIZEOF_INT: number;\n\n  /**\n   * @type {number}\n   * @const\n   */\n  export const FILE_IDENTIFIER_LENGTH: number;\n\n  /**\n   * @enum {number}\n   */\n  export enum Encoding { UTF8_BYTES, UTF16_STRING }\n\n  /**\n   * @type {Int32Array}\n   * @const\n   */\n  export var int32: Int32Array;\n\n  /**\n   * @type {Float32Array}\n   * @const\n   */\n  export var float32: Float32Array;\n\n  /**\n   * @type {Float64Array}\n   * @const\n   */\n  export var float64: Float64Array;\n\n  /**\n   * @type {boolean}\n   * @const\n   */\n  export var isLittleEndian: boolean;\n\n  ////////////////////////////////////////////////////////////////////////////////\n\n  export class Long {\n\n    /**\n     * @type {number}\n     * @const\n     */\n    public low: number;\n\n    /**\n     * @type {number}\n     * @const\n     */\n    public high: number;\n\n    /**\n     * @type {flatbuffers.Long}\n     * @const\n     */\n    static ZERO: Long;\n\n    /**\n     * @constructor\n     * @param {number} high\n     * @param {number} low\n     */\n    constructor(low: number, high: number);\n\n    /**\n     * @returns {number}\n     */\n    toFloat64(): number;\n\n    /**\n     * @param {flatbuffers.Long} other\n     * @returns {boolean}\n     */\n    equals(other): boolean;\n  }\n\n\n  ////////////////////////////////////////////////////////////////////////////////\n\n  export class Builder {\n\n    /**\n     * @constructor\n     * @param {number=} initial_size\n     */\n    constructor(initial_size?: number);\n\n    /**\n     * In order to save space, fields that are set to their default value\n     * don't get serialized into the buffer. Forcing defaults provides a\n     * way to manually disable this optimization.\n     *\n     * @param {boolean} forceDefaults true always serializes default values\n     */\n    forceDefaults(forceDefaults: boolean): void;\n\n    /**\n     * Get the ByteBuffer representing the FlatBuffer. Only call this after you've\n     * called finish(). The actual data starts at the ByteBuffer's current position,\n     * not necessarily at 0.\n     *\n     * @returns {flatbuffers.ByteBuffer}\n     */\n    dataBuffer(): ByteBuffer;\n\n    /**\n     * Get the ByteBuffer representing the FlatBuffer. Only call this after you've\n     * called finish(). The actual data starts at the ByteBuffer's current position,\n     * not necessarily at 0.\n     *\n     * @returns {Uint8Array}\n     */\n    asUint8Array(): Uint8Array;\n\n    /**\n     * Prepare to write an element of `size` after `additional_bytes` have been\n     * written, e.g. if you write a string, you need to align such the int length\n     * field is aligned to 4 bytes, and the string data follows it directly. If all\n     * you need to do is alignment, `additional_bytes` will be 0.\n     *\n     * @param {number} size This is the of the new element to write\n     * @param {number} additional_bytes The padding size\n     */\n    prep(size: number, additional_bytes: number): void;\n\n    /**\n     * @param {number} byte_size\n     */\n    pad(byte_size: number): void;\n\n    /**\n     * @param {number} value\n     */\n    writeInt8(value: number): void;\n\n    /**\n     * @param {number} value\n     */\n    writeInt16(value: number): void;\n\n    /**\n     * @param {number} value\n     */\n    writeInt32(value: number): void;\n\n    /**\n     * @param {flatbuffers.Long} value\n     */\n    writeInt64(value: Long): void;\n\n    /**\n     * @param {number} value\n     */\n    writeFloat32(value: number): void;\n\n    /**\n     * @param {number} value\n     */\n    writeFloat64(value: number): void;\n\n    /**\n     * @param {number} value\n     */\n    addInt8(value: number): void;\n\n    /**\n     * @param {number} value\n     */\n    addInt16(value: number): void;\n\n    /**\n     * @param {number} value\n     */\n    addInt32(value: number): void;\n\n    /**\n     * @param {flatbuffers.Long} value\n     */\n    addInt64(value: Long): void;\n\n    /**\n     * @param {number} value\n     */\n    addFloat32(value: number): void;\n\n    /**\n     * @param {number} value\n     */\n    addFloat64(value: number): void;\n\n    /**\n     * @param {number} voffset\n     * @param {number} value\n     * @param {number} defaultValue\n     */\n    addFieldInt8(voffset: number, value: number, defaultValue: number): void;\n\n    /**\n     * @param {number} voffset\n     * @param {number} value\n     * @param {number} defaultValue\n     */\n    addFieldInt16(voffset: number, value: number, defaultValue: number): void;\n\n    /**\n     * @param {number} voffset\n     * @param {number} value\n     * @param {number} defaultValue\n     */\n    addFieldInt32(voffset: number, value: number, defaultValue: number): void;\n\n    /**\n     * @param {number} voffset\n     * @param {flatbuffers.Long} value\n     * @param {flatbuffers.Long} defaultValue\n     */\n    addFieldInt64(voffset: number, value: Long, defaultValue: Long): void;\n\n    /**\n     * @param {number} voffset\n     * @param {number} value\n     * @param {number} defaultValue\n     */\n    addFieldFloat32(voffset: number, value: number, defaultValue: number): void;\n\n    /**\n     * @param {number} voffset\n     * @param {number} value\n     * @param {number} defaultValue\n     */\n    addFieldFloat64(voffset: number, value: number, defaultValue: number): void;\n\n    /**\n     * @param {number} voffset\n     * @param {flatbuffers.Offset} value\n     * @param {flatbuffers.Offset} defaultValue\n     */\n    addFieldOffset(voffset: number, value: Offset, defaultValue: Offset): void;\n\n    /**\n     * Structs are stored inline, so nothing additional is being added. `d` is always 0.\n     *\n     * @param {number} voffset\n     * @param {flatbuffers.Offset} value\n     * @param {flatbuffers.Offset} defaultValue\n     */\n    addFieldStruct(voffset: number, value: Offset, defaultValue: Offset): void;\n\n    /**\n     * Structures are always stored inline, they need to be created right\n     * where they're used.  You'll get this assertion failure if you\n     * created it elsewhere.\n     *\n     * @param {flatbuffers.Offset} obj The offset of the created object\n     */\n    nested(obj: Offset): void;\n\n    /**\n     * Should not be creating any other object, string or vector\n     * while an object is being constructed\n     */\n    notNested(): void;\n\n    /**\n     * Set the current vtable at `voffset` to the current location in the buffer.\n     *\n     * @param {number} voffset\n     */\n    slot(voffset: number): void;\n\n    /**\n     * @returns {flatbuffers.Offset} Offset relative to the end of the buffer.\n     */\n    offset(): Offset;\n\n    /**\n     * Doubles the size of the backing ByteBuffer and copies the old data towards\n     * the end of the new buffer (since we build the buffer backwards).\n     *\n     * @param {flatbuffers.ByteBuffer} bb The current buffer with the existing data\n     * @returns {flatbuffers.ByteBuffer} A new byte buffer with the old data copied\n     * to it. The data is located at the end of the buffer.\n     */\n    static growByteBuffer(bb: ByteBuffer): ByteBuffer;\n\n    /**\n     * Adds on offset, relative to where it will be written.\n     *\n     * @param {flatbuffers.Offset} offset The offset to add\n     */\n    addOffset(offset: Offset): void;\n\n    /**\n     * Start encoding a new object in the buffer.  Users will not usually need to\n     * call this directly. The FlatBuffers compiler will generate helper methods\n     * that call this method internally.\n     *\n     * @param {number} numfields\n     */\n    startObject(numfields: number): void;\n\n    /**\n     * Finish off writing the object that is under construction.\n     *\n     * @returns {flatbuffers.Offset} The offset to the object inside `dataBuffer`\n     */\n    endObject(): Offset;\n\n    /**\n     * @param {flatbuffers.Offset} root_table\n     * @param {string=} file_identifier\n     */\n    finish(root_table: Offset, file_identifier?: string): void;\n\n    /**\n     * This checks a required field has been set in a given table that has\n     * just been constructed.\n     *\n     * @param {flatbuffers.Offset} table\n     * @param {number} field\n     */\n    requiredField(table: Offset, field: number): void;\n\n    /**\n     * Start a new array/vector of objects.  Users usually will not call\n     * this directly. The FlatBuffers compiler will create a start/end\n     * method for vector types in generated code.\n     *\n     * @param {number} elem_size The size of each element in the array\n     * @param {number} num_elems The number of elements in the array\n     * @param {number} alignment The alignment of the array\n     */\n    startVector(elem_size: number, num_elems: number, alignment: number): void;\n\n    /**\n     * Finish off the creation of an array and all its elements. The array must be\n     * created with `startVector`.\n     *\n     * @returns {flatbuffers.Offset} The offset at which the newly created array\n     * starts.\n     */\n    endVector(): Offset;\n\n    /**\n     * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed\n     * instead of a string, it is assumed to contain valid UTF-8 encoded data.\n     *\n     * @param {string|Uint8Array} s The string to encode\n     * @return {flatbuffers.Offset} The offset in the buffer where the encoded string starts\n     */\n    createString(s: string|Uint8Array): Offset;\n\n  }\n\n  ////////////////////////////////////////////////////////////////////////////////\n  \n\n  class ByteBuffer {\n\n    /**\n     * @constructor\n     * @param {Uint8Array} bytes\n     */\n    constructor(bytes: Uint8Array);\n\n    /**\n     * @param {number} byte_size\n     * @returns {flatbuffers.ByteBuffer}\n     */\n    static allocate(byte_size: number): ByteBuffer;\n\n    /**\n     * @returns {Uint8Array}\n     */\n    bytes(): Uint8Array;\n\n    /**\n     * @returns {number}\n     */\n    position(): number;\n\n    /**\n     * @param {number} position\n     */\n    setPosition(position: number): void;\n\n    /**\n     * @returns {number}\n     */\n    capacity(): number;\n\n    /**\n     * @param {number} offset\n     * @returns {number}\n     */\n    readInt8(offset: number): number;\n\n    /**\n     * @param {number} offset\n     * @returns {number}\n     */\n    readUint8(offset: number): number;\n\n    /**\n     * @param {number} offset\n     * @returns {number}\n     */\n    readInt16(offset: number): number;\n\n    /**\n     * @param {number} offset\n     * @returns {number}\n     */\n    readUint16(offset: number): number;\n\n    /**\n     * @param {number} offset\n     * @returns {number}\n     */\n    readInt32(offset: number): number;\n\n    /**\n     * @param {number} offset\n     * @returns {number}\n     */\n    readUint32(offset: number): number;\n\n    /**\n     * @param {number} offset\n     * @returns {flatbuffers.Long}\n     */\n    readInt64(offset: number): Long;\n\n    /**\n     * @param {number} offset\n     * @returns {flatbuffers.Long}\n     */\n    readUint64(offset: number): Long;\n\n    /**\n     * @param {number} offset\n     * @returns {number}\n     */\n    readFloat32(offset: number): number;\n\n    /**\n     * @param {number} offset\n     * @returns {number}\n     */\n    readFloat64(offset: number): number;\n\n    /**\n     * @param {number} offset\n     * @param {number} value\n     */\n    writeInt8(offset: number, value: number): void;\n\n    /**\n     * @param {number} offset\n     * @param {number} value\n     */\n    writeInt16(offset: number, value: number): void;\n\n    /**\n     * @param {number} offset\n     * @param {number} value\n     */\n    writeInt32(offset: number, value: number): void;\n\n    /**\n     * @param {number} offset\n     * @param {flatbuffers.Long} value\n     */\n    writeInt64(offset: number, value: Long): void;\n\n    /**\n     * @param {number} offset\n     * @param {number} value\n     */\n    writeFloat32(offset: number, value: number): void;\n\n    /**\n     * @param {number} offset\n     * @param {number} value\n     */\n    writeFloat64(offset: number, value: number): void;\n\n    /**\n     * Look up a field in the vtable, return an offset into the object, or 0 if the\n     * field is not present.\n     *\n     * @param {number} bb_pos\n     * @param {number} vtable_offset\n     * @returns {number}\n     */\n    __offset(bb_pos: number, vtable_offset: number): number;\n\n    /**\n     * Initialize any Table-derived type to point to the union at the given offset.\n     *\n     * @param {flatbuffers.Table} t\n     * @param {number} offset\n     * @returns {flatbuffers.Table}\n     */\n    __union(t: Table, offset: number): Table;\n\n    /**\n     * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.\n     * This allocates a new string and converts to wide chars upon each access.\n     *\n     * To avoid the conversion to UTF-16, pass flatbuffers.Encoding.UTF8_BYTES as\n     * the \"optionalEncoding\" argument. This is useful for avoiding conversion to\n     * and from UTF-16 when the data will just be packaged back up in another\n     * FlatBuffer later on.\n     *\n     * @param {number} offset\n     * @param {flatbuffers.Encoding=} optionalEncoding Defaults to UTF16_STRING\n     * @returns {string|Uint8Array}\n     */\n    __string(offset: number, optionalEncoding?: Encoding): string|Uint8Array;\n\n    /**\n     * Retrieve the relative offset stored at \"offset\"\n     * @param {number} offset\n     * @returns {number}\n     */\n    __indirect(offset: number): number;\n\n    /**\n     * Get the start of data of a vector whose offset is stored at \"offset\" in this object.\n     *\n     * @param {number} offset\n     * @returns {number}\n     */\n    __vector(offset: number): number;\n\n    /**\n     * Get the length of a vector whose offset is stored at \"offset\" in this object.\n     *\n     * @param {number} offset\n     * @returns {number}\n     */\n    __vector_len(offset: number): number;\n\n    /**\n     * @param {string} ident\n     * @returns {boolean}\n     */\n    __has_identifier(ident: string): boolean;\n\n  }\n\n}"
}