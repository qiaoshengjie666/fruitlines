{
  "__type__": "cc.TextAsset",
  "_name": "wx.d",
  "_objFlags": 0,
  "_native": "",
  "text": "/**\n * 取消一个先前通过调用 requestAnimationFrame 方法添加到计划中的动画帧请求\n */\ndeclare function cancelAnimationFrame(requestID: number): void;\n\n/**\n * 在下次进行重绘时执行。\n */\ndeclare function requestAnimationFrame(callback: ()=>void): number;\n\n/**\n * 可取消由 setTimeout() 方法设置的定时器。\n */\ndeclare function clearTimeout(timeoutID: number): void;\n\n/**\n * 可取消由 setInterval() 方法设置的定时器。\n */\ndeclare function clearInterval(intervalID: number): void;\n\n/**\n * 设定一个定时器，在定时到期以后执行注册的回调函数\n */\ndeclare function setTimeout(callback: ()=>void, delay: number, rest: any): number;\n\n/**\n * 设定一个定时器，按照指定的周期（以毫秒计）来执行注册的回调函数\n */\ndeclare function setInterval(callback: ()=>void, delay: number, rest: any): number;\n\ndeclare const wx: {\n\n    cloud: {\n        callFunction(options: Object):any;\n        database(options?: object): Database;\n        collection(name: string): Collection;\n        doc(id: string | number): Document;\n        get(options?: object): Promise<Result>;\n        init(options): void;\n    }\n\n    /**\n     *  sessionFrom\tstring\t''\t否\t会话来源\t\n        showMessageCard\tboolean\tfalse\t否\t是否显示会话内消息卡片，设置此参数为 true，用户进入客服会话之后会收到一个消息卡片，通过以下三个参数设置卡片的内容\t\n        sendMessageTitle\tstring\t''\t否\t会话内消息卡片标题\t\n        sendMessagePath\tstring\t''\t否\t会话内消息卡片路径\t\n        sendMessageImg\tstring\t''\t否\t会话内消息卡片图片路径\t\n        success\tfunction\t\t否\t接口调用成功的回调函数\t\n        fail\tfunction\t\t否\t接口调用失败的回调函数\t\n        complete\tfunction\t\t否\t接口调用结束的回调函数（调用成功、失败都会执行）\n     */\n\n    openCustomerServiceConversation(any):any;\n\n    navigateToMiniProgram(any):any;\n\n    createUserInfoButton(any):any;\n    /**\n     * 创建一个画布对象。首次调用创建的是显示在屏幕上的画布，之后调用创建的都是离屏画布。\n     */\n    createCanvas(): Canvas;\n    /**\n     * 只有开放数据域能调用，获取主域和开放数据域共享的 sharedCanvas\n     */\n    getSharedCanvas(): Canvas;\n    /**\n     * 创建一个图片对象\n     */\n    createImage(): Image;\n    /**\n     * 获取一行文本的行高\n     */\n    getTextLineHeight(object: {fontStyle:string,fontWeight:string,fontSize:number,fontFamily:string,text:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): number;\n    /**\n     * 加载自定义字体文件\n     */\n    loadFont(path: string): string;\n    /**\n     * 可以修改渲染帧率。默认渲染帧率为 60 帧每秒。修改后，requestAnimationFrame 的回调频率会发生改变。\n     */\n    setPreferredFramesPerSecond(fps: number): void;\n    /**\n     * 退出当前小游戏\n     */\n    exitMiniProgram(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * 返回小程序启动参数\n     */\n    getLaunchOptionsSync(): LaunchOption;\n    /**\n     * 监听小游戏隐藏到后台事件。锁屏、按 HOME 键退到桌面、显示在聊天顶部等操作会触发此事件。\n     */\n    onHide(callback: ()=>void): void;\n    /**\n     * 取消监听小游戏隐藏到后台事件。锁屏、按 HOME 键退到桌面、显示在聊天顶部等操作会触发此事件。\n     */\n    offHide(callback: ()=>void): void;\n    /**\n     * 监听小游戏回到前台的事件\n     */\n    onShow(callback: (res)=>void): void;\n    /**\n     * 取消监听小游戏回到前台的事件\n     */\n    offShow(callback: ()=>void): void;\n    /**\n     * 获取系统信息\n     */\n    getSystemInfo(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * wx.getSystemInfo 的同步版本\n     */\n    getSystemInfoSync(): SystemInfo;\n    /**\n     * 监听音频中断结束，在收到 onAudioInterruptionBegin 事件之后，小程序内所有音频会暂停，收到此事件之后才可再次播放成功\n     */\n    onAudioInterruptionEnd(callback: ()=>void): void;\n    /**\n     * 取消监听音频中断结束，在收到 onAudioInterruptionBegin 事件之后，小程序内所有音频会暂停，收到此事件之后才可再次播放成功\n     */\n    offAudioInterruptionEnd(callback: ()=>void): void;\n    /**\n     * 监听音频因为受到系统占用而被中断开始，以下场景会触发此事件：闹钟、电话、FaceTime 通话、微信语音聊天、微信视频聊天。此事件触发后，小程序内所有音频会暂停。\n     */\n    onAudioInterruptionBegin(callback: ()=>void): void;\n    /**\n     * 取消监听音频因为受到系统占用而被中断开始，以下场景会触发此事件：闹钟、电话、FaceTime 通话、微信语音聊天、微信视频聊天。此事件触发后，小程序内所有音频会暂停。\n     */\n    offAudioInterruptionBegin(callback: ()=>void): void;\n    /**\n     * 监听全局错误事件\n     */\n    onError(callback: ()=>void): void;\n    /**\n     * 取消监听全局错误事件\n     */\n    offError(callback: ()=>void): void;\n    /**\n     * 监听开始触摸事件\n     */\n    onTouchStart(callback: ()=>void): void;\n    /**\n     * 取消监听开始触摸事件\n     */\n    offTouchStart(callback: ()=>void): void;\n    /**\n     * 监听触点移动事件\n     */\n    onTouchMove(callback: ()=>void): void;\n    /**\n     * 取消监听触点移动事件\n     */\n    offTouchMove(callback: ()=>void): void;\n    /**\n     * 监听触摸结束事件\n     */\n    onTouchEnd(callback: ()=>void): void;\n    /**\n     * 取消监听触摸结束事件\n     */\n    offTouchEnd(callback: ()=>void): void;\n    /**\n     * 监听触点失效事件\n     */\n    onTouchCancel(callback: ()=>void): void;\n    /**\n     * 取消监听触点失效事件\n     */\n    offTouchCancel(callback: ()=>void): void;\n    /**\n     * 监听加速度数据，频率：5次/秒，接口调用后会自动开始监听，可使用 wx.stopAccelerometer 停止监听。\n     */\n    onAccelerometerChange(callback: ()=>void): void;\n    startAccelerometer(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    stopAccelerometer(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * 获取设备电量\n     */\n    getBatteryInfo(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * wx.getBatteryInfo 的同步版本\n     */\n    getBatteryInfoSync(): string;\n    getClipboardData(object: {success?:(res:any)=>void,fail?:(res:any)=>void,complete?:(res:any)=>void}): void;\n    setClipboardData(object: {data:string,success?:(res:any)=>void,fail?:(res:any)=>void,complete?:(res:any)=>void}): void;\n    /**\n     * 监听罗盘数据，频率：5 次/秒，接口调用后会自动开始监听，可使用 wx.stopCompass 停止监听。\n     */\n    onCompassChange(callback: ()=>void): void;\n    startCompass(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    stopCompass(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * 获取网络类型\n     */\n    getNetworkType(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    onNetworkStatusChange(callback: ()=>void): void;\n    getScreenBrightness(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    setKeepScreenOn(object: {keepScreenOn:boolean,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    setScreenBrightness(object: {value:number,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    vibrateShort(object?: {success?:(res:any)=>void,fail?:(res:any)=>void,complete?:(res:any)=>void}): void;\n    vibrateLong(object?: {success?:(res:any)=>void,fail?:(res:any)=>void,complete?:(res:any)=>void}): void;\n    /**\n     * 获取全局唯一的文件管理器\n     */\n    getFileSystemManager(): FileSystemManager;\n    /**\n     * 获取当前的地理位置、速度。当用户离开小程序后，此接口无法调用；当用户点击“显示在聊天顶部”时，此接口可继续调用。\n     */\n    getLocation(object: {type:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * 下载文件资源到本地，客户端直接发起一个 HTTP GET 请求，返回文件的本地文件路径。\n     */\n    downloadFile(object: {url:string,header:Object,filePath:string,fail:(res:any)=>void,complete:(res:any)=>void}): DownloadTask;\n    /**\n     * 发起网络请求。\n     */\n    request(object: {url:string,data:string|Object,header:Object,method:string,dataType:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): RequestTask;\n    /**\n     * 创建一个 WebSocket 连接。最多同时存在 2 个 WebSocket 连接。\n     */\n    connectSocket(object: {url:string,header:Object,method:string,protocols:any[],success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): SocketTask;\n    /**\n     * 关闭 WeSocket 连接\n     */\n    closeSocket(object: {code:number,reason:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * 监听WebSocket 连接打开事件\n     */\n    onSocketOpen(callback: ()=>void): void;\n    /**\n     * 监听WebSocket 连接关闭事件\n     */\n    onSocketClose(callback: ()=>void): void;\n    /**\n     * 监听WebSocket 接受到服务器的消息事件\n     */\n    onSocketMessage(callback: ()=>void): void;\n    /**\n     * 监听WebSocket 错误事件\n     */\n    onSocketError(callback: ()=>void): void;\n    /**\n     * 通过 WebSocket 连接发送数据，需要先 wx.connectSocket，并在 wx.onSocketOpen 回调之后才能发送。\n     */\n    sendSocketMessage(object: {data:any[],success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * 将本地资源上传到开发者服务器，客户端发起一个 HTTPS POST 请求，其中 content-type 为 multipart/form-data 。\n     */\n    uploadFile(object: {url:string,filePath:string,name:string,header:Object,formData:Object,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): UploadTask;\n    /**\n     * 通过 wx.login 接口获得的用户登录态拥有一定的时效性。用户越久未使用小程序，用户登录态越有可能失效。反之如果用户一直在使用小程序，则用户登录态一直保持有效。具体时效逻辑由微信维护，对开发者透明。开发者只需要调用 wx.checkSession 接口检测当前用户登录态是否有效。登录态过期后开发者可以再调用 wx.login 获取新的用户登录态。\n     */\n    checkSession(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * 调用接口获取登录凭证（code）进而换取用户登录态信息，包括用户的唯一标识（openid） 及本次登录的 会话密钥（session_key）等。用户数据的加解密通讯需要依赖会话密钥完成。\n     */\n    login(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    authorize(object: {scope:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * 在无须用户授权的情况下，批量获取用户信息。该接口只在开放数据域下可用\n     */\n    getUserInfo(object: {withCredentials:boolean,lang:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    getSetting(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    openSetting(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    getWeRunData(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * 拉取当前用户所有同玩好友的托管数据。该接口只可在开放数据域下使用\n     */\n    getFriendCloudStorage(object: {keyList:any[],success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * 在小游戏是通过群分享卡片打开的情况下，可以通过调用该接口获取群同玩成员的游戏数据。该接口只可在开放数据域下使用。\n     */\n    getGroupCloudStorage(object: {shareTicket:string,keyList:any[],success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * 获取当前用户托管数据当中对应 key 的数据。该接口只可在开放数据域下使用\n     */\n    getUserCloudStorage(object: {keyList:any[],success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * 删除用户托管数据当中对应 key 的数据。\n     */\n    removeUserCloudStorage(object: {keyList:any[],success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * 对用户托管数据进行写数据操作，允许同时写多组 KV 数据。\n     */\n    setUserCloudStorage(object: {KVDataList:any[],success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * 获取开放数据域\n     */\n    getOpenDataContext(): OpenDataContext;\n    /**\n     * 监听主域发送的消息\n     */\n    onMessage(callback: (data:any)=>void): void;\n    getShareInfo(object: {shareTicket:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    hideShareMenu(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * 监听用户点击右上角菜单的“转发”按钮时触发的事件\n     */\n    onShareAppMessage(callback: ()=>void): void;\n    /**\n     * 取消监听用户点击右上角菜单的“转发”按钮时触发的事件\n     */\n    offShareAppMessage(callback: ()=>void): void;\n    showShareMenu(object: {withShareTicket:boolean,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * 主动拉起转发，进入选择通讯录界面。\n     */\n    shareAppMessage(object: {title:string,imageUrl:string,query?:string,success?:(res:any)=>void,fail?:(res:any)=>void,complete?:(res:any)=>void}): void;\n    updateShareMenu(object: {withShareTicket:boolean,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    setEnableDebug(object: {enableDebug:boolean,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * 清理本地数据缓存\n     */\n    clearStorage(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * wx.clearStorage 的同步版本\n     */\n    clearStorageSync(): void;\n    /**\n     * 从本地缓存中异步获取指定 key 的内容\n     */\n    getStorage(object: {key:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * 异步获取当前storage的相关信息\n     */\n    getStorageInfo(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * wx.getStorage 的同步版本\n     */\n    getStorageSync(key: string): Object|string;\n    /**\n     * wx.getStorageInfo 的同步版本\n     */\n    getStorageInfoSync(): Object;\n    /**\n     * 从本地缓存中移除指定 key\n     */\n    removeStorage(object: {key:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * wx.removeStorage 的同步版本\n     */\n    removeStorageSync(key: string): void;\n    /**\n     * 将数据存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容。\n     */\n    setStorage(object: {key:string,data:Object|string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * wx.setStorage 的同步版本\n     */\n    setStorageSync(key: string, data: Object|string): void;\n    /**\n     * 隐藏消息提示框\n     */\n    hideToast(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    hideLoading(object: {success?:(res:any)=>void,fail?:(res:any)=>void,complete?:(res:any)=>void}): void;\n    /**\n     * 显示模态对话框\n     */\n    showModal(object: {title:string,content:string,showCancel:boolean,cancelText:string,cancelColor:string,confirmText:string,confirmColor:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * 显示消息提示框\n     */\n    showToast(object: {title:Object,icon?:Object,image?:Object,success?:(res:any)=>void,fail?:(res:any)=>void,complete?:(res:any)=>void}): void;\n    showLoading(object: {title:string,mask?:boolean,success?:(res:any)=>void,fail?:(res:any)=>void,complete?:(res:any)=>void}): void;\n    /**\n     * 参数\n     */\n    showActionSheet(object: {itemList:any[],itemColor:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * 隐藏键盘\n     */\n    hideKeyboard(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * 监听键盘输入事件\n     */\n    onKeyboardInput(callback: ()=>void): void;\n    /**\n     * 取消监听键盘输入事件\n     */\n    offKeyboardInput(callback: ()=>void): void;\n    /**\n     * 监听用户点击键盘 Confirm 按钮时的事件\n     */\n    onKeyboardConfirm(callback: ()=>void): void;\n    /**\n     * 取消监听用户点击键盘 Confirm 按钮时的事件\n     */\n    offKeyboardConfirm(callback: ()=>void): void;\n    /**\n     * 监听监听键盘收起的事件\n     */\n    onKeyboardComplete(callback: ()=>void): void;\n    /**\n     * 取消监听监听键盘收起的事件\n     */\n    offKeyboardComplete(callback: ()=>void): void;\n    /**\n     * 显示键盘\n     */\n    showKeyboard(object: {defaultValue:string,maxLength:number,multiple:boolean,confirmHold:boolean,confirmType:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * 动态设置通过右上角按钮拉起的菜单的样式。\n     */\n    setMenuStyle(object: {style:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * 当在配置中设置 showStatusBarStyle 时，屏幕顶部会显示状态栏。此接口可以修改状态栏的样式。\n     */\n    setStatusBarStyle(object: {style:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * 监听窗口尺寸变化事件\n     */\n    onWindowResize(callback: ()=>void): void;\n    /**\n     * 取消监听窗口尺寸变化事件\n     */\n    offWindowResize(callback: ()=>void): void;\n    /**\n     * 返回值\n     */\n    getUpdateManager(): UpdateManager;\n    /**\n     * 创建一个 Worker 线程，目前限制最多只能创建一个 Worker，创建下一个 Worker 前请调用 Worker.terminate\n     */\n    createWorker(): Worker;\n    /**\n     * 创建一个 InnerAudioContext 实例\n     */\n    createInnerAudioContext(): InnerAudioContext;\n    getRecorderManager(): RecorderManager;\n    /**\n     * 从本地相册选择图片或使用相机拍照。\n     */\n    chooseImage(object: {count:number}): void;\n    /**\n     * 预览图片\n     */\n    previewImage(object: {current:string,urls:any[],success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    saveImageToPhotosAlbum(object: {filePath:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * 创建视频\n     */\n    createVideo(object: {x:number,y:number,width:number,height:number,src:number,poster:number,initialTime:number,playbackRate:number,live:number,objectFit:number,controls:number,autoplay:number,loop:number,muted:number}): Video;\n    /**\n     * 获取性能管理器\n     */\n    getPerformance(): Performance;\n    /**\n     * 加快触发 JavaScrpitCore Garbage Collection（垃圾回收），GC 时机是由 JavaScrpitCore 来控制的，并不能保证调用后马上触发 GC。\n     */\n    triggerGC(): void;\n    /**\n     * 发起米大师支付\n     */\n    requestMidasPayment(object: {mode:string,env:number,offerId:string,currencyType:string,platform:string,buyQuantity:number,zoneId:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n}\n\ndeclare interface Canvas {\n    /**\n     * 获取画布对象的绘图上下文\n     */\n    getContext(contextType: string, contextAttributes: {antialias:boolean,preserveDrawingBuffer:boolean,antialiasSamples:number}): RenderingContext;\n    /**\n     * 将当前 Canvas 保存为一个临时文件，并生成相应的临时文件路径。\n     */\n    toTempFilePath(object: {x:number,y:number,width:number,height:number,destWidth:number,destHeight:number,fileType:string,quality:number,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): string;\n    /**\n     * 把画布上的绘制内容以一个 data URI 的格式返回\n     */\n    toDataURL(): string;\n    /**\n     * Canvas.toTempFilePath 的同步版本\n     */\n    toTempFilePathSync(object: {x:number,y:number,width:number,height:number,destWidth:number,destHeight:number,fileType:string,quality:number}): void;\n}\n\ndeclare interface FileSystemManager {\n    /**\n     * 判断文件/目录是否存在\n     */\n    access(object: {path:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * FileSystemManager.access 的同步版本\n     */\n    accessSync(path: string): void;\n    /**\n     * 复制文件\n     */\n    copyFile(object: {srcPath:string,destPath:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * FileSystemManager.copyFile 的同步版本\n     */\n    copyFileSync(srcPath: string, destPath: string): void;\n    /**\n     * 获取该小程序下的 本地临时文件 或 本地缓存文件 信息\n     */\n    getFileInfo(object: {filePath:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * 获取该小程序下已保存的本地缓存文件列表\n     */\n    getSavedFileList(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * 创建目录\n     */\n    mkdir(object: {dirPath:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * FileSystemManager.mkdir 的同步版本\n     */\n    mkdirSync(dirPath: string): void;\n    /**\n     * 删除该小程序下已保存的本地缓存文件\n     */\n    removeSavedFile(object: {filePath:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * 读取本地文件内容\n     */\n    readFile(object: {filePath:string,encoding:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * 重命名文件，可以把文件从 oldPath 移动到 newPath\n     */\n    rename(object: {oldPath:string,newPath:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * 删除目录\n     */\n    rmdir(object: {dirPath:Object,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * 读取目录内文件列表\n     */\n    readdir(object: {dirPath:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * FileSystemManager.readdir 的同步版本\n     */\n    readdirSync(dirPath: string): string[];\n    /**\n     * FileSystemManager.rename 的同步版本\n     */\n    renameSync(oldPath: string, newPath: string): void;\n    /**\n     * FileSystemManager.rmdir 的同步版本\n     */\n    rmdirSync(dirPath: {}): void;\n    /**\n     * FileSystemManager.readFile 的同步版本\n     */\n    readFileSync(filePath: string, encoding: string): string[];\n    /**\n     * 保存临时文件到本地。此接口会移动临时文件，因此调用成功后，tempFilePath 将不可用。\n     */\n    saveFile(object: {tempFilePath:string,filePath:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * 获取文件 Stats 对象\n     */\n    stat(object: {path:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): Stats;\n    /**\n     * FileSystemManager.saveFile 的同步版本\n     */\n    saveFileSync(tempFilePath: string, filePath: string): number;\n    /**\n     * FileSystemManager.stat 的同步版本\n     */\n    statSync(path: string): Stats;\n    /**\n     * 删除文件\n     */\n    unlink(object: {filePath:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * 解压文件\n     */\n    unzip(object: {zipFilePath:string,targetPath:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * FileSystemManager.unlink 的同步版本\n     */\n    unlinkSync(filePath: string): void;\n    /**\n     * 写文件\n     */\n    writeFile(object: {filePath:string,data:any[],encoding:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * FileSystemManager.writeFile 的同步版本\n     */\n    writeFileSync(filePath: string, data: string|ArrayBuffer, encoding: string): void;\n}\n\ndeclare interface Stats {\n    /**\n     * 判断当前文件是否一个目录\n     */\n    isDirectory(): boolean;\n    /**\n     * 判断当前文件是否一个普通文件\n     */\n    isFile(): boolean;\n}\n\ndeclare interface DownloadTask {\n    abort(): void;\n    onProgressUpdate(callback: ()=>void): void;\n}\n\ndeclare interface RequestTask {\n    abort(): void;\n}\n\ndeclare interface SocketTask {\n    /**\n     * 关闭 WebSocket 连接\n     */\n    close(object: {code:number,reason:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n    /**\n     * 监听WebSocket 连接打开事件\n     */\n    onOpen(callback: ()=>void): void;\n    /**\n     * 监听WebSocket 连接关闭事件\n     */\n    onClose(callback: ()=>void): void;\n    /**\n     * 监听WebSocket 错误事件\n     */\n    onError(callback: ()=>void): void;\n    /**\n     * 监听WebSocket 接受到服务器的消息事件\n     */\n    onMessage(callback: ()=>void): void;\n    /**\n     * 通过 WebSocket 连接发送数据\n     */\n    send(object: {data:any[],success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\n}\n\ndeclare interface UploadTask {\n    abort(): void;\n    onProgressUpdate(callback: ()=>void): void;\n}\n\ndeclare interface OpenDataContext {\n    /**\n     * 向开放数据域发送消息\n     */\n    postMessage(message: {}): void;\n}\n\ndeclare interface UpdateManager {\n    /**\n     * 应用更新包并重启\n     */\n    applyUpdate(): void;\n    /**\n     * 监听检查更新结果回调\n     */\n    onCheckForUpdate(callback: ()=>void): void;\n    /**\n     * 监听更新包下载成功回调\n     */\n    onUpdateReady(callback: ()=>void): void;\n    /**\n     * 监听更新包下载失败回调\n     */\n    onUpdateFailed(callback: ()=>void): void;\n}\n\ndeclare interface Worker {\n    /**\n     * 监听接收主线程/Worker 线程向当前线程发送的消息\n     */\n    onMessage(callback: ()=>void): void;\n    /**\n     * 向主线程/Worker 线程发送的消息。\n     */\n    postMessage(message: {}): void;\n    /**\n     * 结束当前 worker 线程，仅限在主线程 worker 对象上调用。\n     */\n    terminate(): void;\n}\n\ndeclare interface InnerAudioContext {\n    /**\n     * 销毁当前实例\n     */\n    destroy(): void;\n    /**\n     * 取消监听音频进入可以播放状态的事件\n     */\n    offCanplay(callback: ()=>void): void;\n    /**\n     * 监听音频暂停事件\n     */\n    onPause(callback: ()=>void): void;\n    /**\n     * 监听音频停止事件\n     */\n    onStop(callback: ()=>void): void;\n    /**\n     * 取消监听音频停止事件\n     */\n    offStop(callback: ()=>void): void;\n    /**\n     * 监听音频自然播放至结束的事件\n     */\n    onEnded(callback: ()=>void): void;\n    /**\n     * 取消监听音频自然播放至结束的事件\n     */\n    offEnded(callback: ()=>void): void;\n    /**\n     * 监听音频播放进度更新事件\n     */\n    onTimeUpdate(callback: ()=>void): void;\n    /**\n     * 监听音频播放事件\n     */\n    onPlay(callback: ()=>void): void;\n    /**\n     * 监听音频播放错误事件\n     */\n    onError(callback: ()=>void): void;\n    /**\n     * 取消监听音频暂停事件\n     */\n    offPause(callback: ()=>void): void;\n    /**\n     * 监听音频加载中事件，当音频因为数据不足，需要停下来加载时会触发\n     */\n    onWaiting(callback: ()=>void): void;\n    /**\n     * 取消监听音频加载中事件，当音频因为数据不足，需要停下来加载时会触发\n     */\n    offWaiting(callback: ()=>void): void;\n    /**\n     * 监听音频进行跳转操作的事件\n     */\n    onSeeking(callback: ()=>void): void;\n    /**\n     * 取消监听音频进行跳转操作的事件\n     */\n    offSeeking(callback: ()=>void): void;\n    /**\n     * 监听音频完成跳转操作的事件\n     */\n    onSeeked(callback: ()=>void): void;\n    /**\n     * 取消监听音频完成跳转操作的事件\n     */\n    offSeeked(callback: ()=>void): void;\n    /**\n     * 取消监听音频播放事件\n     */\n    offPlay(callback: ()=>void): void;\n    /**\n     * 取消监听音频播放进度更新事件\n     */\n    offTimeUpdate(callback: ()=>void): void;\n    /**\n     * 监听音频进入可以播放状态的事件\n     */\n    onCanplay(callback: ()=>void): void;\n    /**\n     * 取消监听音频播放错误事件\n     */\n    offError(callback: ()=>void): void;\n    /**\n     * 停止。停止后的音频再播放会从头开始播放。\n     */\n    pause(): void;\n    /**\n     * 播放\n     */\n    play(): void;\n    /**\n     * 跳转到指定位置，单位 s\n     */\n    seek(position: number): void;\n}\n\ndeclare interface RecorderManager {\n    /**\n     * 监听录音暂停事件\n     */\n    onPause(callback: ()=>void): void;\n    /**\n     * 监听录音结束事件\n     */\n    onStop(callback: ()=>void): void;\n    /**\n     * 监听已录制完指定帧大小的文件事件。如果设置了 frameSize，则会回调此事件。\n     */\n    onFrameRecorded(callback: ()=>void): void;\n    /**\n     * 监听录音错误事件\n     */\n    onError(callback: ()=>void): void;\n    /**\n     * 监听录音开始事件\n     */\n    onStart(callback: ()=>void): void;\n    /**\n     * 暂停录音\n     */\n    pause(): void;\n    /**\n     * 继续录音\n     */\n    resume(): void;\n    /**\n     * 停止录音\n     */\n    stop(): void;\n    /**\n     * 开始录音\n     */\n    start(object: {duration:number,sampleRate:number,numberOfChannels:number,encodeBitRate:number,format:string,frameSize:number}): void;\n}\n\ndeclare interface Video {\n    /**\n     * 视频退出全屏\n     */\n    exitFullScreen(): Promise<Object>;\n    /**\n     * 取消监听视频暂停事件\n     */\n    offPause(callback: ()=>void): void;\n    /**\n     * 监听视频播放到末尾事件\n     */\n    onEnded(callback: ()=>void): void;\n    /**\n     * 取消监听视频播放到末尾事件\n     */\n    offEnded(callback: ()=>void): void;\n    /**\n     * 监听视频播放进度更新事件\n     */\n    onTimeUpdate(callback: ()=>void): void;\n    /**\n     * 取消监听视频播放进度更新事件\n     */\n    offTimeUpdate(callback: ()=>void): void;\n    /**\n     * 监听视频错误事件\n     */\n    onError(callback: ()=>void): void;\n    /**\n     * 取消监听视频错误事件\n     */\n    offError(callback: ()=>void): void;\n    /**\n     * 监听视频播放事件\n     */\n    onPlay(callback: ()=>void): void;\n    /**\n     * 监听视频暂停事件\n     */\n    onPause(callback: ()=>void): void;\n    /**\n     * 取消监听视频缓冲事件\n     */\n    offWaiting(callback: ()=>void): void;\n    /**\n     * 监听视频缓冲事件\n     */\n    onWaiting(callback: ()=>void): void;\n    /**\n     * 取消监听视频播放事件\n     */\n    offPlay(callback: ()=>void): void;\n    /**\n     * 暂停视频\n     */\n    pause(): Promise<Object>;\n    /**\n     * 播放视频\n     */\n    play(): Promise<Object>;\n    /**\n     * 视频全屏\n     */\n    requestFullScreen(): Promise<Object>;\n    /**\n     * 视频跳转\n     */\n    seek(time: number): Promise<Object>;\n    /**\n     * 停止视频\n     */\n    stop(): Promise<Object>;\n}\n\ndeclare interface Performance {\n    /**\n     * 可以获取当前时间以微秒为单位的时间戳\n     */\n    now(): number;\n}\n\n\ndeclare interface Image {\n    /**\n     * 图片的 URL\n     */\n    src: string;\n    /**\n    * 图片的真实宽度\n    */\n    width: number;\n    /**\n    * 图片的真实高度\n    */\n    height: number;\n    /**\n     * 图片的加载完成\n     */\n    onload: () => void;\n}\n\ndeclare class LaunchOption {\n    /** 场景值*/\n    scene: number;\n    /** 启动参数*/\n    query: Object;\n    /** 当前小游戏是否被显示在聊天顶部*/\n    isSticky: boolean;\n    /** shareTicket*/\n    shareTicket: string;\n}\n\ndeclare class SystemInfo {\n    /** 手机品牌*/\n    brand: string;\n    /** 手机型号*/\n    model: string;\n    /**\t设备像素比 */\n    pixelRatio: number;\n    /** 屏幕宽度*/\n    screenWidth: number;\n    /** 屏幕高度*/\n    screenHeight: number;\n    /** 可使用窗口宽度*/\n    windowWidth: number;\n    /** 可使用窗口高度*/\n    windowHeight: number;\n    /** 微信设置的语言*/\n    language: string;\n    /** 微信版本号*/\n    version: string;\n    /** 操作系统版本*/\n    system: string;\n    /** 客户端平台*/\n    platform: string\n    /** 用户字体大小设置。以“我-设置 - 通用 - 字体大小”中的设置为准，单位 px。*/\n    fontSizeSetting: number;\n    /** 客户端基础库版本*/\n    SDKVersion: string;\n    /** 性能等级*/\n    benchmarkLevel: number;\n    /** 电量，范围 1 - 100*/\n    battery: number;\n    /** wifi 信号强度，范围 0 - 4 */\n    wifiSignal: number;\n}\n\ndeclare class Stats {\n    /**\n     * 文件的类型和存取的权限，对应 POSIX stat.st_mode\n     */\n    mode: string;\n    /**\n     * 文件大小，单位：B，对应 POSIX stat.st_size\n     */\n    size: number;\n    /**\n     * 文件最近一次被存取或被执行的时间，UNIX 时间戳，对应 POSIX stat.st_atime\n     */\n    lastAccessedTime: number;\n    /**\n    * 文件最后一次被修改的时间，UNIX 时间戳，对应 POSIX stat.st_mtime\n    */\n    lastModifiedTime: number;\n}\n\n /**\n  * 通过 Canvas.getContext('2d') 接口可以获取 CanvasRenderingContext2D 对象。CanvasRenderingContext2D 实现了 HTML The 2D rendering context 定义的大部分属性、方法。通过 Canvas.getContext('webgl') 接口可以获取 WebGLRenderingContext 对象。 WebGLRenderingContext 实现了 WebGL 1.0 定义的所有属性、方法、常量。\n  * 2d 接口支持情况\n  * iOS/Android 不支持的 2d 属性和接口\n  * globalCompositeOperation 不支持以下值： source-in source-out destination-atop lighter copy。如果使用，不会报错，但是将得到与预期不符的结果。\n  * isPointInPath\n  * WebGL 接口支持情况\n  * iOS/Android 不支持的 WebGL 接\n   */\ndeclare interface RenderingContext {}"
}